<div class="space-y-6">
	<!-- Header -->
	<div class="mb-6">
		<h1 class="text-3xl font-semibold text-white mb-6">Stats</h1>

		<!-- Filters -->
		<div class="flex flex-wrap gap-3">
			<form method="GET" action="/dashboard" id="dashboardForm" class="flex flex-wrap gap-3">
				<!-- Metric Toggle -->
				<select name="metric" id="metricSelect"
				 class="px-4 py-2 bg-dark-card border border-dark-border rounded-lg text-gray-300 focus:outline-none focus:border-blue-500">
					<option value="tokens" <%= query.metric === 'tokens' || !query.metric ? 'selected' : '' %>>Show:
						Tokens (M)</option>
					<option value="cost" <%= query.metric === 'cost' ? 'selected' : '' %>>Show: Cost ($)</option>
				</select>

				<!-- Group By -->
				<select name="groupBy" id="groupBySelect"
				 class="px-4 py-2 bg-dark-card border border-dark-border rounded-lg text-gray-300 focus:outline-none focus:border-blue-500">
					<option value="user" <%= query.groupBy === 'user' ? 'selected' : '' %>>Group by: User</option>
					<option value="model" <%= query.groupBy === 'model' ? 'selected' : '' %>>Group by: Model</option>
				</select>

				<!-- Period Filter -->
				<select name="period" id="periodSelect"
				 class="px-4 py-2 bg-dark-card border border-dark-border rounded-lg text-gray-300 focus:outline-none focus:border-blue-500">
					<option value="week" <%= query.period === 'week' ? 'selected' : '' %>>Last Week</option>
					<option value="month" <%= query.period === 'month' ? 'selected' : '' %>>This Month</option>
					<option value="all" <%= query.period === 'all' ? 'selected' : '' %>>All Time</option>
				</select>

				<!-- User Filter -->
				<select name="user" id="userSelect"
				 class="px-4 py-2 bg-dark-card border border-dark-border rounded-lg text-gray-300 focus:outline-none focus:border-blue-500">
					<option value="">All Users</option>
					<% if (filters.users && filters.users.length > 0) { %>
					<% filters.users.forEach(user => { %>
					<option value="<%= user %>" <%= query.user === user ? 'selected' : '' %>><%= user %></option>
					<% }) %>
					<% } %>
				</select>

				<!-- Model Filter -->
				<select name="model" id="modelSelect"
				 class="px-4 py-2 bg-dark-card border border-dark-border rounded-lg text-gray-300 focus:outline-none focus:border-blue-500">
					<option value="">All Models</option>
					<% if (filters.models && filters.models.length > 0) { %>
					<% filters.models.forEach(model => { %>
					<option value="<%= model %>" <%= query.model === model ? 'selected' : '' %>><%= model %></option>
					<% }) %>
					<% } %>
				</select>

				<!-- Date Navigation -->
				<div class="flex items-center gap-2 ml-auto">
					<button type="button" class="p-2 text-gray-400 hover:text-white">
						<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7">
							</path>
						</svg>
					</button>
					<span class="text-gray-300 px-3">
						<%= new Date().toLocaleDateString('en-US', { month: 'long', year: 'numeric' }) %>
					</span>
					<button type="button" class="p-2 text-gray-400 hover:text-white">
						<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
							<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7">
							</path>
						</svg>
					</button>
				</div>
			</form>
		</div>
	</div>

	<%
    // Calculate summary statistics
    let totalTokenCost = 0;
    let totalTokens = 0;
    let uniqueUsers = new Set();
    let totalDays = 0;

    if (stats && stats.stats) {
        const uniqueDates = new Set();
        stats.stats.forEach(day => {
            totalTokenCost += day.totalCost || 0;
            totalTokens += day.totalTokens || 0;
            uniqueUsers.add(day.username);
            uniqueDates.add(day.date);
        });
        totalDays = uniqueDates.size;
    }
    
    // Format tokens in millions
    const totalTokensInMillions = (totalTokens / 1000000).toFixed(2);
    const isTokensView = query.metric === 'tokens';
    %>

	<!-- Stats Cards Container -->
	<div class="flex justify-center gap-6 flex-wrap">
		<!-- Total Stats Card with Donut Chart -->
		<div class="bg-dark-card rounded-xl p-8 max-w-md w-full" id="donutChartCard">
			<div class="flex justify-between items-start gap-2">
				<div class="flex-1">
					<p class="text-gray-400 text-sm mb-3"><%= isTokensView ? 'Total tokens' : 'Total cost' %></p>
					<p class="text-4xl font-bold text-white">
						<% if (isTokensView) { %>
						<%= totalTokensInMillions %>M
						<% } else { %>
						$<%= totalTokenCost.toFixed(2) %>
						<% } %>
					</p>
					<p class="text-gray-500 text-sm mt-2"><%= uniqueUsers.size %> users â€¢ <%= totalDays %> days</p>
				</div>
				<div class="chart-container-small" style="position: relative;">
					<canvas id="tokenCostDonut"></canvas>
					<!-- Custom tooltip container -->
					<div id="chartjs-tooltip"></div>
				</div>
			</div>
		</div>

		<!-- Stats Distribution List Card -->
		<div class="bg-dark-card rounded-xl p-8 max-w-md w-full" id="costDistributionCard">
			<div class="h-full flex flex-col">
				<p class="text-gray-400 text-sm mb-4 flex-shrink-0">
					<%= isTokensView ? 'Token Distribution' : 'Cost Distribution' %></p>
				<div id="costDistributionList" class="flex-1 overflow-y-auto pr-2"
				 style="max-height: calc(100% - 2rem);">
					<!-- This will be populated by JavaScript -->
				</div>
			</div>
		</div>
	</div>

	<!-- Daily Stats Chart -->
	<div class="bg-dark-card rounded-xl p-6">
		<div class="mb-4">
			<h3 class="text-lg font-semibold text-white"><%= isTokensView ? 'Daily token usage' : 'Daily cost' %></h3>
		</div>
		<div class="chart-container">
			<canvas id="dailyCostChart"></canvas>
		</div>

		<!-- Legend -->
		<div class="mt-4 flex flex-wrap gap-4 text-xs" id="chartLegend">
			<!-- Legend will be dynamically populated by JavaScript -->
		</div>
	</div>
</div>
</div>

<!-- Chart.js Scripts -->
<style>
/* Custom tooltip styles */
#chartjs-tooltip {
    position: absolute;
    background: rgba(26, 26, 26, 0.95);
    border: 1px solid #3a3a3a;
    border-radius: 6px;
    color: #9CA3AF;
    font-size: 13px;
    padding: 12px 16px;
    pointer-events: none;
    z-index: 100;
    white-space: nowrap;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    transition: all 0.1s ease;
    display: none;
}

#chartjs-tooltip.active {
    display: block;
}

#chartjs-tooltip .tooltip-title {
    font-weight: bold;
    font-size: 14px;
    margin-bottom: 8px;
    color: #fff;
    border-bottom: 1px solid #3a3a3a;
    padding-bottom: 6px;
}

#chartjs-tooltip .tooltip-body {
    margin-top: 6px;
}

#chartjs-tooltip .tooltip-body-item {
    display: flex;
    align-items: center;
    margin: 4px 0;
}

#chartjs-tooltip .tooltip-body-item .color-box {
    width: 12px;
    height: 12px;
    border-radius: 2px;
    margin-right: 8px;
    flex-shrink: 0;
}

#chartjs-tooltip .tooltip-body-item .label {
    color: #e5e7eb;
}

/* Custom scrollbar for cost distribution list */
#costDistributionList::-webkit-scrollbar {
    width: 6px;
}

#costDistributionList::-webkit-scrollbar-track {
    background: rgba(58, 58, 58, 0.3);
    border-radius: 3px;
}

#costDistributionList::-webkit-scrollbar-thumb {
    background: rgba(156, 163, 175, 0.3);
    border-radius: 3px;
}

#costDistributionList::-webkit-scrollbar-thumb:hover {
    background: rgba(156, 163, 175, 0.5);
}

/* Firefox scrollbar */
#costDistributionList {
    scrollbar-width: thin;
    scrollbar-color: rgba(156, 163, 175, 0.3) rgba(58, 58, 58, 0.3);
}

/* Chart container sizing - responsive */
.chart-container-small {
    width: 60%;
    height: 60%;
}
</style>
<script>
// Chart defaults for dark theme
Chart.defaults.color = '#9CA3AF';
Chart.defaults.borderColor = '#3a3a3a';

// Pass server-side variables to client-side
const totalTokenCost = <%= totalTokenCost %>;
const totalTokens = <%= totalTokens %>;
const stats = <%- JSON.stringify(stats) %>;
const chartData = <%- JSON.stringify(chartData) %>;
const groupBy = '<%= query.groupBy || "user" %>';
const metric = '<%= query.metric || "tokens" %>';
const isTokensView = metric === 'tokens';

// Model colors mapping
const modelColors = {
    'anthropic/claude-3.5-sonnet': '#60A5FA',
    'anthropic/claude-3-opus': '#A78BFA',
    'anthropic/claude-3-haiku': '#34D399',
    'openai/gpt-4': '#F87171',
    'openai/gpt-3.5-turbo': '#FBBF24',
    'other': '#6B7280'
};

// Process data for charts based on groupBy
const processedData = {};
const allGroups = new Set();
const groupTotals = {};

// Define consistent colors
const colorPalette = [
    'rgba(96, 165, 250, 0.8)',   // blue
    'rgba(167, 139, 250, 0.8)',  // purple
    'rgba(52, 211, 153, 0.8)',   // green
    'rgba(248, 113, 113, 0.8)',  // red
    'rgba(251, 191, 36, 0.8)',   // amber
    'rgba(251, 146, 60, 0.8)',   // orange
    'rgba(244, 114, 182, 0.8)',  // pink
    'rgba(148, 163, 184, 0.8)',  // slate
];

const groupColorMap = {};

// Calculate totals based on groupBy parameter and metric
if (stats && stats.stats) {
    if (groupBy === 'model') {
        // Group by model for donut chart
        stats.stats.forEach(stat => {
            if (stat.models) {
                stat.models.forEach(model => {
                    const modelKey = `${model.provider}/${model.name}`;
                    if (!groupTotals[modelKey]) {
                        groupTotals[modelKey] = 0;
                    }
                    if (isTokensView) {
                        // Sum tokens for model
                        groupTotals[modelKey] += (model.inputTokens + model.outputTokens);
                    } else {
                        // Sum cost for model
                        groupTotals[modelKey] += model.cost;
                    }
                    allGroups.add(modelKey);
                });
            }
        });
    } else {
        // Group by user (default)
        stats.stats.forEach(stat => {
            if (!groupTotals[stat.username]) {
                groupTotals[stat.username] = 0;
            }
            if (isTokensView) {
                groupTotals[stat.username] += stat.totalTokens;
            } else {
                groupTotals[stat.username] += stat.totalCost;
            }
            allGroups.add(stat.username);
        });
    }
}

// Assign colors to groups (users or models)
Array.from(allGroups).forEach((group, idx) => {
    groupColorMap[group] = colorPalette[idx % colorPalette.length];
});

// Custom HTML tooltip function
function getOrCreateTooltip(chart) {
    let tooltipEl = document.getElementById('chartjs-tooltip');

    if (!tooltipEl) {
        tooltipEl = document.createElement('div');
        tooltipEl.id = 'chartjs-tooltip';
        document.body.appendChild(tooltipEl);
    }

    return tooltipEl;
}

function externalTooltipHandler(context) {
    // Tooltip Element
    const {chart, tooltip} = context;
    const tooltipEl = getOrCreateTooltip(chart);

    // Hide if no tooltip
    if (tooltip.opacity === 0) {
        tooltipEl.classList.remove('active');
        return;
    }

    // Set Text
    if (tooltip.body) {
        const titleLines = tooltip.title || [];
        const bodyLines = tooltip.body.map(b => b.lines);

        // Clear previous content
        tooltipEl.innerHTML = '';

        // Add title only if it exists and is not null
        if (titleLines.length > 0 && titleLines[0]) {
            const titleDiv = document.createElement('div');
            titleDiv.className = 'tooltip-title';
            titleDiv.textContent = titleLines[0];
            tooltipEl.appendChild(titleDiv);
        }

        // Add body
        const bodyDiv = document.createElement('div');
        bodyDiv.className = 'tooltip-body';

        bodyLines.forEach((body, i) => {
            const colors = tooltip.labelColors[i];
            const itemDiv = document.createElement('div');
            itemDiv.className = 'tooltip-body-item';

            const colorBox = document.createElement('span');
            colorBox.className = 'color-box';
            colorBox.style.background = colors.backgroundColor;

            const label = document.createElement('span');
            label.className = 'label';
            // Ensure full text is shown
            label.textContent = body[0];

            itemDiv.appendChild(colorBox);
            itemDiv.appendChild(label);
            bodyDiv.appendChild(itemDiv);
        });

        tooltipEl.appendChild(bodyDiv);
    }

    const {offsetLeft: positionX, offsetTop: positionY} = chart.canvas;

    // Display, position, and show tooltip
    tooltipEl.classList.add('active');
    tooltipEl.style.left = positionX + tooltip.caretX + 'px';
    tooltipEl.style.top = positionY + tooltip.caretY + 'px';
}

// Token Cost Donut Chart (dynamic based on groupBy)
const tokenCtx = document.getElementById('tokenCostDonut').getContext('2d');
new Chart(tokenCtx, {
    type: 'doughnut',
    data: {
        labels: Object.keys(groupTotals),
        datasets: [{
            data: Object.values(groupTotals),
            backgroundColor: Object.keys(groupTotals).map(group => groupColorMap[group]),
            borderWidth: 0,
        }]
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        cutout: '70%',
        plugins: {
            legend: { display: false },
            tooltip: {
                enabled: false, // Disable default tooltip
                position: 'nearest',
                external: externalTooltipHandler,
                callbacks: {
                    label: function(context) {
                        const label = context.label;
                        const value = context.parsed;
                        const total = isTokensView ? totalTokens : totalTokenCost;
                        const percentage = ((value / total) * 100).toFixed(1);
                        // Return full label text based on metric
                        if (isTokensView) {
                            const valueInMillions = (value / 1000000).toFixed(2);
                            return `${label}: ${valueInMillions}M (${percentage}%)`;
                        } else {
                            return `${label}: $${value.toFixed(2)} (${percentage}%)`;
                        }
                    },
                    title: function() {
                        return null; // No title needed
                    }
                }
            }
        }
    }
});

// Process data for stacked bar chart based on groupBy and metric
if (stats && stats.stats) {
    if (groupBy === 'model') {
        // Group by model
        stats.stats.forEach(stat => {
            if (!processedData[stat.date]) {
                processedData[stat.date] = {};
            }
            // Group by model
            if (stat.models) {
                stat.models.forEach(model => {
                    const modelKey = `${model.provider}/${model.name}`;
                    if (!processedData[stat.date][modelKey]) {
                        processedData[stat.date][modelKey] = 0;
                    }
                    if (isTokensView) {
                        processedData[stat.date][modelKey] += (model.inputTokens + model.outputTokens);
                    } else {
                        processedData[stat.date][modelKey] += model.cost;
                    }
                });
            }
        });
    } else {
        // Group by user (default)
        stats.stats.forEach(stat => {
            if (!processedData[stat.date]) {
                processedData[stat.date] = {};
            }
            if (!processedData[stat.date][stat.username]) {
                processedData[stat.date][stat.username] = 0;
            }
            if (isTokensView) {
                processedData[stat.date][stat.username] += stat.totalTokens;
            } else {
                processedData[stat.date][stat.username] += stat.totalCost;
            }
        });
    }
}

// Get unique dates and sort them
const uniqueDates = Object.keys(processedData).sort();

// Create datasets for stacked bar chart (one dataset per group)
const datasets = Array.from(allGroups).map((group) => ({
    label: group,
    data: uniqueDates.map(date => processedData[date]?.[group] || 0),
    backgroundColor: groupColorMap[group],
    borderWidth: 0,
}));

// Daily Cost Chart (Stacked Bar)
const dailyCtx = document.getElementById('dailyCostChart').getContext('2d');
new Chart(dailyCtx, {
    type: 'bar',
    data: {
        labels: uniqueDates.map(date => {
            const d = new Date(date);
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }),
        datasets: datasets
    },
    options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            x: {
                stacked: true,
                grid: { display: false },
                ticks: { color: '#9CA3AF' }
            },
            y: {
                stacked: true,
                beginAtZero: true,
                grid: { color: '#3a3a3a' },
                ticks: {
                    color: '#9CA3AF',
                    callback: function(value) {
                        if (isTokensView) {
                            // Format as millions
                            return (value / 1000000).toFixed(1) + 'M';
                        } else {
                            return '$' + value.toFixed(0);
                        }
                    }
                }
            }
        },
        plugins: {
            legend: { display: false },
            tooltip: {
                backgroundColor: '#1a1a1a',
                borderColor: '#3a3a3a',
                borderWidth: 1,
                mode: 'index',
                intersect: false,
                callbacks: {
                    title: function(tooltipItems) {
                        return tooltipItems[0].label;
                    },
                    label: function(context) {
                        const label = context.dataset.label;
                        const value = context.parsed.y;
                        if (value > 0) {
                            if (isTokensView) {
                                const valueInM = (value / 1000000).toFixed(2);
                                return label + ': ' + valueInM + 'M';
                            } else {
                                return label + ': $' + value.toFixed(2);
                            }
                        }
                        return null; // Don't show items with 0
                    },
                    footer: function(tooltipItems) {
                        let sum = 0;
                        tooltipItems.forEach(function(tooltipItem) {
                            sum += tooltipItem.parsed.y;
                        });
                        if (isTokensView) {
                            return 'Total: ' + (sum / 1000000).toFixed(2) + 'M';
                        } else {
                            return 'Total: $' + sum.toFixed(2);
                        }
                    }
                }
            }
        }
    }
});

// Populate the legend
const legendContainer = document.getElementById('chartLegend');
Array.from(allGroups).forEach((group) => {
    const legendItem = document.createElement('div');
    legendItem.className = 'flex items-center gap-2';

    const colorBox = document.createElement('span');
    colorBox.className = 'w-3 h-3 rounded';
    colorBox.style.backgroundColor = groupColorMap[group];

    const label = document.createElement('span');
    label.className = 'text-gray-400';
    label.textContent = group;

    legendItem.appendChild(colorBox);
    legendItem.appendChild(label);
    legendContainer.appendChild(legendItem);
});

// Populate the cost distribution list
const costListContainer = document.getElementById('costDistributionList');
if (costListContainer) {
    // Create a wrapper for scrollable content
    const scrollWrapper = document.createElement('div');
    scrollWrapper.className = 'space-y-1';

    // Sort groups by cost (descending)
    const sortedGroups = Object.entries(groupTotals)
        .sort((a, b) => b[1] - a[1]);

    sortedGroups.forEach(([group, value], index) => {
        const total = isTokensView ? totalTokens : totalTokenCost;
        const percentage = ((value / total) * 100).toFixed(1);

        // Create list item (more compact)
        const listItem = document.createElement('div');
        listItem.className = 'flex items-center justify-between py-1.5 border-b border-dark-border';
        if (index === sortedGroups.length - 1) {
            listItem.classList.add('border-0');
        }

        // Left side: color box and name
        const leftDiv = document.createElement('div');
        leftDiv.className = 'flex items-center gap-2 flex-1 min-w-0';

        const colorBox = document.createElement('span');
        colorBox.className = 'w-2.5 h-2.5 rounded flex-shrink-0';
        colorBox.style.backgroundColor = groupColorMap[group];

        const nameDiv = document.createElement('div');
        nameDiv.className = 'truncate text-xs text-gray-300';
        nameDiv.title = group; // Show full name on hover
        nameDiv.textContent = group;

        leftDiv.appendChild(colorBox);
        leftDiv.appendChild(nameDiv);

        // Right side: value with percentage on same line
        const rightDiv = document.createElement('div');
        rightDiv.className = 'flex items-center gap-2 ml-2';

        const valueSpan = document.createElement('span');
        valueSpan.className = 'text-xs font-semibold text-white';
        if (isTokensView) {
            const valueInM = (value / 1000000).toFixed(2);
            valueSpan.textContent = `${valueInM}M`;
        } else {
            valueSpan.textContent = `$${value.toFixed(2)}`;
        }

        const percentSpan = document.createElement('span');
        percentSpan.className = 'text-xs text-gray-500';
        percentSpan.textContent = `(${percentage}%)`;

        rightDiv.appendChild(valueSpan);
        rightDiv.appendChild(percentSpan);

        listItem.appendChild(leftDiv);
        listItem.appendChild(rightDiv);
        scrollWrapper.appendChild(listItem);
    });

    // Add scrollable content to container
    costListContainer.appendChild(scrollWrapper);

    // Add total at the bottom (sticky)
    const totalDiv = document.createElement('div');
    totalDiv.className = 'flex justify-between items-center pt-2 mt-2 border-t border-dark-border sticky bottom-0 bg-dark-card';
    if (isTokensView) {
        const totalInM = (totalTokens / 1000000).toFixed(2);
        totalDiv.innerHTML = `
            <span class="text-xs font-semibold text-gray-400">Total</span>
            <span class="text-xs font-bold text-white">${totalInM}M</span>
        `;
    } else {
        totalDiv.innerHTML = `
            <span class="text-xs font-semibold text-gray-400">Total</span>
            <span class="text-xs font-bold text-white">$${totalTokenCost.toFixed(2)}</span>
        `;
    }
    costListContainer.appendChild(totalDiv);

    // Match the height of the donut chart card
    setTimeout(() => {
        const donutCard = document.getElementById('donutChartCard');
        const distCard = document.getElementById('costDistributionCard');
        if (donutCard && distCard) {
            const donutHeight = donutCard.offsetHeight;
            distCard.style.height = donutHeight + 'px';
        }
    }, 100);
}

// Helper function for colors
function getColor(index, alpha = 1) {
    const colors = [
        `rgba(96, 165, 250, ${alpha})`,   // blue
        `rgba(167, 139, 250, ${alpha})`,  // purple
        `rgba(52, 211, 153, ${alpha})`,   // green
        `rgba(248, 113, 113, ${alpha})`,  // red
        `rgba(251, 191, 36, ${alpha})`,   // amber
        `rgba(251, 146, 60, ${alpha})`,   // orange
        `rgba(244, 114, 182, ${alpha})`,  // pink
        `rgba(148, 163, 184, ${alpha})`,  // slate
    ];
    return colors[index % colors.length];
}

// Add event listeners for form submission
document.addEventListener('DOMContentLoaded', function() {
    const form = document.getElementById('dashboardForm');
    const selects = ['metricSelect', 'groupBySelect', 'periodSelect', 'userSelect', 'modelSelect'];

    selects.forEach(selectId => {
        const selectElement = document.getElementById(selectId);
        if (selectElement) {
            selectElement.addEventListener('change', function() {
                form.submit();
            });
        }
    });
});
</script>
